<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: rollFormula.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: rollFormula.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import tokenize from './formulaTokenizer';
import validateFormula from './validateFormula';
import * as formulaParser from './formulaParser';
import evaluateFormula from './evaluateFormula';
import {objectMakerReduceHelper} from "./helpers";

/**
 * @typedef ResultRange
 * @type {object}
 * @property {ResultEntry} result The result when evaluated in this range
 * @property {string} variable The name of the variable
 * @property {number} minValue The lowest value for which this result is applicable
 * @property {number} maxValue The highest value for which this result is applicable
 */

/**
 * @param {object} p
 * @param {RPNTokenList[]} p.expressions
 * @param {Function} p.macrosWithCertainty
 * @param {string[]} p.rolls
 * @param {string[]} p.uncertainValues
 * @param {ResultEntry[]} p.result
 * @param {number} p.maxRange
 * @param {SideEffects} p.initialSideEffects
 * @returns {ResultRange[]}
 */
const buildResultRange =
  ({ expressions, macrosWithCertainty, rolls, uncertainValues, result, maxRange = 40, initialSideEffects }) =>
  [...Array(maxRange).keys()].reduce((accum, testValue) => {
      const { sideEffects, result: currentResult } = evaluateFormula({
        expressions,
        macros: macrosWithCertainty(testValue),
        rolls // don't need to pass a new one in because we mutate the old one
      });
      if (currentResult.every((value, index) => value === accum.slice(-1)[0].result[index])) {
        return accum;
      }
      return [
        ...accum.slice(0, -1),
        {
          ...accum.slice(-1)[0],
          maxValue: testValue - 1,
        },
        {
          minValue: testValue,
          result: currentResult,
          sideEffects,
        }
      ];
    },
    [
      {
        variable: uncertainValues[0],
        minValue: 0,
        result,
        sideEffects: initialSideEffects,
      }
    ]
  );

/**
 * @typedef RolledFormula
 * @type {object}
 * @property {ResultEntry[]|ResultRange[]} result Either the results from evaluation OR an array
 *                                      of results at multiple input values for a given variable
 * @property {RollLog} rolls Log of all rolls made as part of the evaluation
 * @property {SideEffects} sideEffects Side effects applied from this roll
 * @property {MacroMap} macros Macros that were included in the initial expression
 * @property {MacroMap} allMacros All macros - expression, collection, and inline
 */

/**
 * Validate, parse, and evaluate a formula, potentially pulling in collection data if needed
 * @param {string} formula
 * @param {object.&lt;string,string>} collectionFormulasMap
 * @returns {RolledFormula}
 */
const rollFormula = (formula, collectionFormulasMap) => {
  const validity = validateFormula(formula);
  if (validity.length > 0) {
    return {
      result: [`Invalid formula! Issues: ${validity.join(', ')}`],
      rolls: [],
    };
  }
  const tokens = tokenize(formula);

  const { expressions, macros, unassignedVariables } = formulaParser.parseTokens(tokens);

  const macrosFromCollection = unassignedVariables.length > 0
    ? formulaParser.getMacrosFromCollection(collectionFormulasMap)
    : {};

  const { variables, usedMacros } = formulaParser.getUnassignedVariablesAndUsedMacros(
    expressions, macros, macrosFromCollection
  );

  const noPromptVariables = variables.filter(variable =>
    [...Object.values(usedMacros), ...expressions].some(clause => clause.some(
        token => token === `^${variable}`
    )));

  // TODO: Determine newly required unassigned macros in the UI
  //       Should only require calling getRollMetadata
  const newMacros = variables
    .filter(variable => !noPromptVariables.includes(variable))
    .reduce((accum, variable) => {
      const value = window.prompt(`Value of ${variable}`, '0');
      return {
        ...accum,
        [variable]: [value],
      };
    }, {});
  const allMacros = {
    ...usedMacros,
    ...newMacros,
    ...noPromptVariables.map(variable => [variable, ['0']]).reduce(objectMakerReduceHelper, {})
  };
  const uncertainValues = Object.entries(allMacros)
    .filter(([, tokens]) => tokens.length === 1 &amp;&amp; tokens[0] === '?')
    .map(([macroName]) => macroName);
  if (uncertainValues.length > 1) {
    throw new Error('Multiple uncertain values are not yet supported.');
  }
  if (uncertainValues.length === 0) {
    const {result, rolls, sideEffects} = evaluateFormula({expressions, macros: allMacros});
    return {result, rolls, sideEffects, allMacros, macros};
  }
  const macrosWithCertainty = value => ({
    ...allMacros,
    [uncertainValues[0]]: [`${value}`],
  });
  const { result, rolls, sideEffects: initialSideEffects } = evaluateFormula({ expressions, macros: macrosWithCertainty(0) });
  const resultRange = buildResultRange({ expressions, macrosWithCertainty, result, rolls, uncertainValues, initialSideEffects });

  return { result: resultRange, rolls, allMacros, macros };
};

export default rollFormula;
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Global</h3><ul><li><a href="global.html#buildResultRange">buildResultRange</a></li><li><a href="global.html#clauseHasMislocatedAssignmentOperator">clauseHasMislocatedAssignmentOperator</a></li><li><a href="global.html#convertFormulaToRoll">convertFormulaToRoll</a></li><li><a href="global.html#convertToRPN">convertToRPN</a></li><li><a href="global.html#evaluate">evaluate</a></li><li><a href="global.html#evaluateExpression">evaluateExpression</a></li><li><a href="global.html#evaluateFormula">evaluateFormula</a></li><li><a href="global.html#getAllRolls">getAllRolls</a></li><li><a href="global.html#getInitialRollIndex">getInitialRollIndex</a></li><li><a href="global.html#getMacroIndex">getMacroIndex</a></li><li><a href="global.html#getMacroName">getMacroName</a></li><li><a href="global.html#getMacrosFromCollection">getMacrosFromCollection</a></li><li><a href="global.html#getNewVariablesReduceHelper">getNewVariablesReduceHelper</a></li><li><a href="global.html#getPropertyByPath">getPropertyByPath</a></li><li><a href="global.html#getRollMetadata">getRollMetadata</a></li><li><a href="global.html#getRollType">getRollType</a></li><li><a href="global.html#getTargetCollection">getTargetCollection</a></li><li><a href="global.html#getUnassignedVariablesAndUsedMacros">getUnassignedVariablesAndUsedMacros</a></li><li><a href="global.html#isConditional">isConditional</a></li><li><a href="global.html#isExpansionOperator">isExpansionOperator</a></li><li><a href="global.html#isGlobalMacroInstance">isGlobalMacroInstance</a></li><li><a href="global.html#isGrouping">isGrouping</a></li><li><a href="global.html#isMacroInstance">isMacroInstance</a></li><li><a href="global.html#isNumber">isNumber</a></li><li><a href="global.html#isOperator">isOperator</a></li><li><a href="global.html#isRoll">isRoll</a></li><li><a href="global.html#isSideEffectOperator">isSideEffectOperator</a></li><li><a href="global.html#isSideEffectVariable">isSideEffectVariable</a></li><li><a href="global.html#isValidToken">isValidToken</a></li><li><a href="global.html#isValue">isValue</a></li><li><a href="global.html#isVariable">isVariable</a></li><li><a href="global.html#isVariableInstance">isVariableInstance</a></li><li><a href="global.html#objectMakerReduceHelper">objectMakerReduceHelper</a></li><li><a href="global.html#op1Precedes">op1Precedes</a></li><li><a href="global.html#operatorOrder">operatorOrder</a></li><li><a href="global.html#parseAssignments">parseAssignments</a></li><li><a href="global.html#parseTokens">parseTokens</a></li><li><a href="global.html#peek">peek</a></li><li><a href="global.html#rollAD">rollAD</a></li><li><a href="global.html#rollFormula">rollFormula</a></li><li><a href="global.html#splitTokenList">splitTokenList</a></li><li><a href="global.html#stripPrefix">stripPrefix</a></li><li><a href="global.html#stripSuffix">stripSuffix</a></li><li><a href="global.html#tokenize">tokenize</a></li><li><a href="global.html#validateAlternatingTokenType">validateAlternatingTokenType</a></li><li><a href="global.html#validateBrackets">validateBrackets</a></li><li><a href="global.html#validateClause">validateClause</a></li><li><a href="global.html#validateFormula">validateFormula</a></li><li><a href="global.html#validateParentheses">validateParentheses</a></li><li><a href="global.html#variableTargetsCollection">variableTargetsCollection</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.3</a> on Sun Mar 15 2020 19:52:36 GMT-0400 (Eastern Daylight Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
