<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: validateFormula.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: validateFormula.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/*
 * Operations on this file are run on formulas prior to their conversion to RPN
 */

import tokenize, { isOperator, isValidToken, isValue, isVariable } from './formulaTokenizer';

const enableLogging = false;
const log = msg => { if (enableLogging) console.log(msg) };

/**
 * Ensure parentheses are balanced
 * @function validateParentheses
 * @example
 * // returns false
 * validateParentheses('())(')
 * // return false
 * validateParentheses('(()')
 * // return true
 * validateParentheses('()')
 *
 * @param {string} clause
 * @returns {boolean} True if valid
 */
export const validateParentheses = clause =>
  Array.from(clause).reduce((depth, currentChar) => {
    switch (currentChar) {
      case '(':
        return depth + 1;
      case ')':
        if (depth &lt;= 0) {
          return NaN;
        }
        return depth - 1;
      default:
        return depth;
    }
  }, 0) === 0;

/**
 * confirm that brackets are only used to contain numbers, e.g., [5]
 *
 * @param {string} clause
 * @returns {boolean} True if valid
 */
const validateBrackets = (clause) => {
  const brackets = clause.match(/\[[^[\]]*]/g);
  return brackets === null || brackets.every(bracket => /^\[\d+]$/.test(bracket));
};

/**
 * confirm that operators and values alternate
 * @function validateAlternatingTokenType
 * @param {string[]} tokens
 * @returns {boolean} True if valid
 */
const validateAlternatingTokenType = tokens => tokens.reduce(
  (accum, token, i) => {
    if (!accum) {
      return false;
    }
    if (i === 0) {
      const result = isValue(token) || token === '(';
      if (!result) {
        log(`clause did not start with ( or value, but with ${token}`)
      }
      return result;
    }
    if (i === tokens.length - 1 &amp;&amp; (isOperator(token) || token === '(')) {
      log(`last token in the clause was ${token}`);
      return false;
    }
    const lastToken = tokens[i-1];
    if (token === '=') {
      const result = (i === 1 &amp;&amp; isVariable(lastToken));
      if (!result) {
        log('= was not the second token or did not follow a variable name');
      }
      return result;
    }
    if (isOperator(lastToken) || lastToken === '(' || lastToken === '=') {
      const result = isValue(token) || token === '(';
      if (!result) {
        log(`An operator, =, or ( was followed by ${token}`);
      }
      return result;
    }
    if (isValue(lastToken) || lastToken === ')') {
      const result = isOperator(token) || token === ')';
      if (!result) {
        log(`A value or ) was followed by ${token}`);
      }
      return result;
    }
    return false;
  },
    true
);

/**
 * Confirm that the clause matches the appropriate format and that the other validators pass
 * @function validateClause
 * @param {string} clause
 * @param {number|string} i clause descriptor
 * @returns {string[]} Empty if valid. Array of found issues.
 */
export const validateClause = (clause, i) => {
  const result = [];

  // TODO: source valid strings from formulaTokenizer.js or some other shared place instead
  if (clause.length === 0 || !clause.match(/^([\^$]?\w(@\w+)?|[#+\-*/&lt;>=:;()[\]{}|&amp;?.])+$/)) {
    log(`${clause} did not match validation regex`);
    result.push(`Invalid characters in clause ${i}`);
  }
  if (!validateBrackets(clause)) {
    log(`${clause} did not have valid brackets`);
    result.push(`Invalid brackets in clause ${i}`);
  }
  if (!validateParentheses(clause)) {
    log(`${clause} did not have valid parentheses`);
    result.push(`Invalid parentheses in clause ${i}`);
  }
  const tokens = tokenize(clause);
  if (tokens == null || tokens.length === 0 || tokens.join('') !== clause) {
    log(`${clause} could not be tokenized`);
    result.push(`Clause ${i} could not be tokenized`);
    return result;
  }
  if (!tokens.every(isValidToken)) {
    log(`${clause} had one or more invalid tokens`);
    const invalidTokens = tokens.filter(token => !isValidToken(token));
    result.push(`Clause ${i} had invalid tokens: ${invalidTokens.join(', ')}`);

    if (enableLogging) {
      invalidTokens.forEach(
        token => console.log(`Invalid token: ${token}`)
      );
    }
    return result;
  }
  if (!validateAlternatingTokenType(tokens)) {
    log(`${clause} did not have proper token order`);
    result.push(`${clause} had improper token order`);
  }
  return result;
};

/**
 * Ensure that assignment only happens at the beginning of a clause
 * @function clauseHasMislocatedAssignmentOperator
 * @param {string[]} clause List of tokens
 * @returns {boolean} True if valid
 */
export const clauseHasMislocatedAssignmentOperator = clause => clause.some(
    (token, i) => token === '='
        &amp;&amp; (clause.length &lt; 3
            || i !== 1
            || !clause[0].match(/^[A-Za-z]\w*(@[A-Za-z]\w+)?$/))
);

/**
 * Perform validation for the entire formula (an unconverted string) one clause at a time
 * @function validateFormula
 * @param {string} formula
 * @returns {string[]} Empty if valid. Array of issues found.
 */
export const validateFormula = (formula) => {
  if (typeof formula !== "string") {
      throw new Error('validateFormula() called with an invalid formula (i.e., of a non-string type)')
  }
  const clauses = formula.split(',');
  const result = clauses.reduce(
    (accum, clause, i) => [
      ...accum,
      ...validateClause(clause, i + 1),
    ],
    []
  );
  if (!enableLogging) {
    return result;
  }
  if (!result) {
    clauses.filter(clause => !validateClause(clause))
      .forEach(clause => log(`invalid clause: ${clause}`));
  }
  return result;
};


export default validateFormula;
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Global</h3><ul><li><a href="global.html#buildResultRange">buildResultRange</a></li><li><a href="global.html#clauseHasMislocatedAssignmentOperator">clauseHasMislocatedAssignmentOperator</a></li><li><a href="global.html#convertFormulaToRoll">convertFormulaToRoll</a></li><li><a href="global.html#convertToRPN">convertToRPN</a></li><li><a href="global.html#evaluate">evaluate</a></li><li><a href="global.html#evaluateExpression">evaluateExpression</a></li><li><a href="global.html#evaluateFormula">evaluateFormula</a></li><li><a href="global.html#getAllRolls">getAllRolls</a></li><li><a href="global.html#getInitialRollIndex">getInitialRollIndex</a></li><li><a href="global.html#getMacroIndex">getMacroIndex</a></li><li><a href="global.html#getMacroName">getMacroName</a></li><li><a href="global.html#getMacrosFromCollection">getMacrosFromCollection</a></li><li><a href="global.html#getNewVariablesReduceHelper">getNewVariablesReduceHelper</a></li><li><a href="global.html#getPropertyByPath">getPropertyByPath</a></li><li><a href="global.html#getRollMetadata">getRollMetadata</a></li><li><a href="global.html#getRollType">getRollType</a></li><li><a href="global.html#getTargetCollection">getTargetCollection</a></li><li><a href="global.html#getUnassignedVariablesAndUsedMacros">getUnassignedVariablesAndUsedMacros</a></li><li><a href="global.html#isGlobalMacroInstance">isGlobalMacroInstance</a></li><li><a href="global.html#isGrouping">isGrouping</a></li><li><a href="global.html#isMacroInstance">isMacroInstance</a></li><li><a href="global.html#isRoll">isRoll</a></li><li><a href="global.html#isValidToken">isValidToken</a></li><li><a href="global.html#isValue">isValue</a></li><li><a href="global.html#objectMakerReduceHelper">objectMakerReduceHelper</a></li><li><a href="global.html#op1Precedes">op1Precedes</a></li><li><a href="global.html#operatorOrder">operatorOrder</a></li><li><a href="global.html#parseAssignments">parseAssignments</a></li><li><a href="global.html#parseTokens">parseTokens</a></li><li><a href="global.html#peek">peek</a></li><li><a href="global.html#reduceHelper">reduceHelper</a></li><li><a href="global.html#rollAD">rollAD</a></li><li><a href="global.html#rollFormula">rollFormula</a></li><li><a href="global.html#splitTokenList">splitTokenList</a></li><li><a href="global.html#stripPrefix">stripPrefix</a></li><li><a href="global.html#stripSuffix">stripSuffix</a></li><li><a href="global.html#tokenize">tokenize</a></li><li><a href="global.html#validateAlternatingTokenType">validateAlternatingTokenType</a></li><li><a href="global.html#validateBrackets">validateBrackets</a></li><li><a href="global.html#validateClause">validateClause</a></li><li><a href="global.html#validateFormula">validateFormula</a></li><li><a href="global.html#validateParentheses">validateParentheses</a></li><li><a href="global.html#variableTargetsCollection">variableTargetsCollection</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.3</a> on Sun Mar 15 2020 19:20:15 GMT-0400 (Eastern Daylight Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
