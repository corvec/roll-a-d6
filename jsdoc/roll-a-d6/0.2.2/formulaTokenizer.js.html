<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: formulaTokenizer.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: formulaTokenizer.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>export const conditionals = ['->', ';', '=>'];
export const logicals = ['&amp;&amp;', '||'];
export const comparators = ['>', '&lt;', '&lt;=', '>=', '==', '&lt;>', '>>', '&lt;&lt;'];
export const arithmetic = ['+', '-', '*', '/'];
export const expansion = ['#+', '#*', '#|', '#&amp;'];
export const sideEffects = [':=','+=','-=', '...'];

/**
 * Used for order of operations when converting to RPN. Earlier groups have a higher precedence than later groups.
 * @example // 5+(6*7)
 * 5+6*7
 * @example // (5+6)>(7*8)
 * 5+6>7*8
 * @example // (5>6)|(7&lt;8)
 * 5>6|7&lt;8
 * @example // ((10+1d4)>>1d20)#+(6+1d6)
 * 10+1d4>>1d20#+6+1d6
 * @example // (((10+1d4)>>1d20)#+(6+1d6)&lt;20)->1d8;0
 * 10+1d4>>1d20#+6+1d6->1d8;0
 *
 * @type {string[][]}
 */
export const operatorOrder = [
  ['(', ')'], conditionals, expansion, logicals, comparators, ['+', '-'], ['*', '/'], sideEffects
];

/**
 * @function
 * @param {string} token
 * @return {boolean}
 */
export const isConditional = token => conditionals.includes(token);
/**
 * @function
 * @param {string} token
 * @return {boolean}
 */
export const isOperator = token => [...arithmetic, ...comparators, ...logicals, ...expansion, ...conditionals, ...sideEffects].includes(token);
/**
 * @function
 * @param {string} token
 * @return {boolean}
 */
export const isExpansionOperator = token => expansion.includes(token);
/**
 * @function
 * @param {string} token
 * @return {boolean}
 */
export const isSideEffectOperator = token => sideEffects.includes(token);

/**
 * @function
 * @param {string} token
 * @return {boolean}
 */
export const isVariable = token => (/^[\^$]?[a-zA-Z]\w*(@[A-Za-z]\w*)?$/.test(token));
/**
 * @function
 * @param {string} token
 * @return {boolean}
 */
export const isVariableInstance = token => (/^[a-zA-Z]\w*(\[\d+]|{\d+})(@[A-Za-z]\w*)?$/.test(token));
/**
 * @function
 * @param {string} token
 * @return {boolean}
 */
export const isSideEffectVariable = token => (/^\$[a-zA-Z]\w*(@[A-Za-z]\w*)?$/.test(token));

/**
 * @function
 * @param {string} token
 * @return {boolean}
 */
export const isNumber = token => !isNaN(token) &amp;&amp; ['string','number'].includes(typeof token)
  &amp;&amp; !isNaN(parseInt(token, 10));

/**
 * Is the token a roll (e.g., '3d6')?
 * @function isRoll
 * @param {string} token
 * @returns {boolean}
 */
export const isRoll = token => /\d+d\d+/.test(token);
/**
 * Is the token a grouping operator (either '(' or ')')?
 * @function isGrouping
 * @param {string} token
 * @returns {boolean}
 */
export const isGrouping = token => ['(', ')'].includes(token);

/**
 * Is the token a dice roll (e.g., '3d6')?
 * @function isValue
 * @param {string} token
 * @returns {boolean}
 */
export const isValue = token => isVariable(token) || isVariableInstance(token) || isRoll(token) || isNumber(token) || token === '?';

/**
 * Is the token valid?
 * @function isValidToken
 * @param {string} token
 * @returns {boolean}
 */
export const isValidToken = token => isOperator(token) || isValue(token) || isGrouping(token) || ['=', '?'].includes(token);


const targetCollectionRegex = /@[A-Za-z]\w+$/;
/**
 * Is this token a variable with a target collection (e.g., 'ac@Defender', which targets 'Defender')
 * @function variableTargetsCollection
 * @param {string} token
 * @returns {boolean}
 */
export const variableTargetsCollection = token => (targetCollectionRegex.test(token));
/**
 * Get the name of the targeted collection
 * @function getTargetCollection
 * @example // returns 'Defender'
 * getTargetCollection('ac@Defender')
 * @param {string} token
 * @returns {string?}
 */
export const getTargetCollection = token => {
  const match = token.match(targetCollectionRegex);
  return match &amp;&amp; match[0].slice(1);
};


/**
 * Strip ^ and $ prefixes off of a token that is a variable name
 * @function stripPrefix
 * @example // returns 'ac'
 * stripPrefix('^ac')
 * @param {string} variable
 * @returns {string}
 */
export const stripPrefix = variable => variable.replace(/^[\^$]+/, '');
/**
 * Strip target and instance suffixes off of a token that is a variable instance
 * @function stripSuffix
 * @example // returns 'atk'
 * stripPrefix('atk[1]')
 * @param {string} variableInstance
 * @returns {string}
 */
export const stripSuffix = variableInstance => variableInstance
  .replace(/@[A-Z]\w*$/, '')
  .replace(/(\[.*]|{.*})$/, '');

/**
 * Split a tokenized list into multiple tokenized lists based on the comma token
 * @function splitTokenList
 * @example // returns [['a'],['c']]
 * splitTokenList(['a', ',', 'c'])
 *
 * @param {string[]} tokens
 * @returns {string[][]}
 */
export const splitTokenList = tokens => tokens.reduce((accum, token) => {
  if (token === ',') {
    return [...accum, []];
  } else {
    return [
      ...accum.slice(0, -1),
      [
        ...accum[accum.length - 1],
        token,
      ],
    ];
  }
}, [[]]);

/**
 * Every token MUST match this Regex.
 * @private
 * @type {RegExp}
 */
const tokenRegex = /([\^$]?[A-Za-z]\w*(\[\d+]|{\d+})?(@[A-Za-z]\w*)?|\w+\b|[()]|[:+\-]=|\.\.\.|->|#[+*&amp;|]|[+*/,;]|[&lt;>=]{1,2}|[|]{2}|&amp;&amp;|\B-\d+|-|\?)/g;

/**
 * Convert a formula from a string into an array of tokens
 * Each token should represent either a value or an operator.
 * @function tokenize
 * @example // returns ['1d20', '+', '5']
 * tokenize('1d20+5')
 *
 * @param {string} formula
 * @returns {string[]} Array of tokens
 */
export const tokenize = formula => formula.match(tokenRegex);

export default tokenize;
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Global</h3><ul><li><a href="global.html#buildResultRange">buildResultRange</a></li><li><a href="global.html#clauseHasMislocatedAssignmentOperator">clauseHasMislocatedAssignmentOperator</a></li><li><a href="global.html#convertFormulaToRoll">convertFormulaToRoll</a></li><li><a href="global.html#convertToRPN">convertToRPN</a></li><li><a href="global.html#evaluate">evaluate</a></li><li><a href="global.html#evaluateExpression">evaluateExpression</a></li><li><a href="global.html#evaluateFormula">evaluateFormula</a></li><li><a href="global.html#getAllRolls">getAllRolls</a></li><li><a href="global.html#getInitialRollIndex">getInitialRollIndex</a></li><li><a href="global.html#getMacroIndex">getMacroIndex</a></li><li><a href="global.html#getMacroName">getMacroName</a></li><li><a href="global.html#getMacrosFromCollection">getMacrosFromCollection</a></li><li><a href="global.html#getNewVariablesReduceHelper">getNewVariablesReduceHelper</a></li><li><a href="global.html#getPropertyByPath">getPropertyByPath</a></li><li><a href="global.html#getRollMetadata">getRollMetadata</a></li><li><a href="global.html#getRollType">getRollType</a></li><li><a href="global.html#getTargetCollection">getTargetCollection</a></li><li><a href="global.html#getUnassignedVariablesAndUsedMacros">getUnassignedVariablesAndUsedMacros</a></li><li><a href="global.html#isConditional">isConditional</a></li><li><a href="global.html#isExpansionOperator">isExpansionOperator</a></li><li><a href="global.html#isGlobalMacroInstance">isGlobalMacroInstance</a></li><li><a href="global.html#isGrouping">isGrouping</a></li><li><a href="global.html#isMacroInstance">isMacroInstance</a></li><li><a href="global.html#isNumber">isNumber</a></li><li><a href="global.html#isOperator">isOperator</a></li><li><a href="global.html#isRoll">isRoll</a></li><li><a href="global.html#isSideEffectOperator">isSideEffectOperator</a></li><li><a href="global.html#isSideEffectVariable">isSideEffectVariable</a></li><li><a href="global.html#isValidToken">isValidToken</a></li><li><a href="global.html#isValue">isValue</a></li><li><a href="global.html#isVariable">isVariable</a></li><li><a href="global.html#isVariableInstance">isVariableInstance</a></li><li><a href="global.html#objectMakerReduceHelper">objectMakerReduceHelper</a></li><li><a href="global.html#op1Precedes">op1Precedes</a></li><li><a href="global.html#operatorOrder">operatorOrder</a></li><li><a href="global.html#parseAssignments">parseAssignments</a></li><li><a href="global.html#parseTokens">parseTokens</a></li><li><a href="global.html#peek">peek</a></li><li><a href="global.html#rollAD">rollAD</a></li><li><a href="global.html#rollFormula">rollFormula</a></li><li><a href="global.html#splitTokenList">splitTokenList</a></li><li><a href="global.html#stripPrefix">stripPrefix</a></li><li><a href="global.html#stripSuffix">stripSuffix</a></li><li><a href="global.html#tokenize">tokenize</a></li><li><a href="global.html#validateAlternatingTokenType">validateAlternatingTokenType</a></li><li><a href="global.html#validateBrackets">validateBrackets</a></li><li><a href="global.html#validateClause">validateClause</a></li><li><a href="global.html#validateFormula">validateFormula</a></li><li><a href="global.html#validateParentheses">validateParentheses</a></li><li><a href="global.html#variableTargetsCollection">variableTargetsCollection</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.3</a> on Sun Mar 15 2020 19:52:36 GMT-0400 (Eastern Daylight Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
