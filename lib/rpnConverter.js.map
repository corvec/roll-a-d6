{"version":3,"sources":["rpnConverter.mjs"],"names":["op1Precedes","op1","op2","finder","op","ary","includes","op1Value","operatorOrder","findIndex","op2Value","placeholderMap","requiresPlaceholder","token","hasOwnProperty","getPlaceholder","convertToRPN","tokens","logRPN","log","args","console","join","result","operatorStack","logState","map","forEach","length","push","pop"],"mappings":"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","sourcesContent":["import { peek } from './helpers';\nimport {isOperator, operatorOrder} from './formulaTokenizer';\n\n/**\n * @param {string} op1\n * @param {string} op2\n * @returns {boolean} True if op1 is of higher precedence than operator 2,\n * e.g., a op1 b op2 c should be grouped as (a op1 b) op2 c\n */\nconst op1Precedes = (op1, op2) => {\n  const finder = op => ary => ary.includes(op);\n  const op1Value = operatorOrder.findIndex(finder(op1));\n  const op2Value = operatorOrder.findIndex(finder(op2));\n  return (op1Value <= op2Value);\n};\n\nconst placeholderMap = {\n  '->': '=>',\n};\nconst requiresPlaceholder = token => placeholderMap.hasOwnProperty(token);\nconst getPlaceholder = token => placeholderMap[token];\n\n/**\n * Convert tokens from infix notation to reverse polish notation, following order of operations and\n * respecting parentheses.\n *\n * @param {string[]} tokens\n * @returns {RPNTokenList}\n */\nconst convertToRPN = (tokens) => {\n  const logRPN = false;\n  const log = (...args) => { if (logRPN) console.log(...args); };\n  log(`convertToRPN(${tokens.join(' ')})`);\n  const result = [];\n  const operatorStack = [];\n  const logState = () => log(`result: '${result.join(' ')}' | ops: [${operatorStack.map(op => `'${op}'`).join(', ')}]`);\n  tokens.forEach(token => {\n    logState();\n    if (requiresPlaceholder(token)) {\n      if (operatorStack.length > 0 && peek(operatorStack) !== '(') {\n        log(`result << ops.pop('${peek(operatorStack)}')`);\n        result.push(operatorStack.pop());\n      }\n      log(`ops << '${getPlaceholder(token)}'`);\n      operatorStack.push(getPlaceholder(token));\n    }\n    if (isOperator(token)) {\n      while (operatorStack.length > 0 && op1Precedes(token, peek(operatorStack))) {\n        log(`result << ops.pop('${peek(operatorStack)}')`);\n        result.push(operatorStack.pop());\n      }\n      log(`ops << '${token}'`);\n      operatorStack.push(token);\n    } else if (token === '(') {\n      log(`ops << '${token}'`);\n      operatorStack.push(token);\n    } else if (token === ')') {\n      while (operatorStack.length > 0 && peek(operatorStack) !== '(') {\n        log(`result << ops.pop('${peek(operatorStack)}')`);\n        result.push(operatorStack.pop());\n      }\n      log(`ops.pop ('${peek(operatorStack)}')`);\n      operatorStack.pop();\n    } else {\n      log(`result << '${token}'`);\n      result.push(token);\n    }\n  });\n  log('EOF');\n  while (operatorStack.length > 0) {\n    log(`result << ops.pop('${peek(operatorStack)}')`);\n    result.push(operatorStack.pop());\n  }\n  logState();\n  return result;\n};\n\nexport default convertToRPN;\n"],"file":"rpnConverter.js"}