{"version":3,"sources":["rollFormula.mjs"],"names":["buildResultRange","expressions","macrosWithCertainty","rolls","uncertainValues","result","maxRange","initialSideEffects","Array","keys","reduce","accum","testValue","sideEffects","currentResult","macros","every","value","index","slice","maxValue","minValue","variable","rollFormula","formula","collectionFormulasMap","validity","length","join","tokens","unassignedVariables","formulaParser","parseTokens","macrosFromCollection","getMacrosFromCollection","variables","usedMacros","getUnassignedVariablesAndUsedMacros","noPromptVariables","filter","Object","values","some","clause","token","newMacros","includes","window","prompt","allMacros","map","objectMakerReduceHelper","entries","macroName","Error","resultRange"],"mappings":"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","sourcesContent":["import tokenize from './formulaTokenizer';\nimport validateFormula from './validateFormula';\nimport * as formulaParser from './formulaParser';\nimport evaluateFormula from './evaluateFormula';\nimport {objectMakerReduceHelper} from \"./helpers\";\n\n/**\n * @typedef ResultRange\n * @type {object}\n * @property {ResultEntry} result The result when evaluated in this range\n * @property {string} variable The name of the variable\n * @property {number} minValue The lowest value for which this result is applicable\n * @property {number} maxValue The highest value for which this result is applicable\n */\n\n/**\n * Determine the result given different values of a single input, and build the ResultRange to model\n * this.\n * @function buildResultRange\n * @param {object} p\n * @param {RPNTokenList[]} p.expressions\n * @param {Function} p.macrosWithCertainty\n * @param {string[]} p.rolls\n * @param {string[]} p.uncertainValues\n * @param {ResultEntry[]} p.result\n * @param {number} p.maxRange\n * @param {SideEffects} p.initialSideEffects\n * @returns {ResultRange[]}\n */\nexport const buildResultRange =\n  ({ expressions, macrosWithCertainty, rolls, uncertainValues, result, maxRange = 40, initialSideEffects }) =>\n  [...Array(maxRange).keys()].reduce((accum, testValue) => {\n      const { sideEffects, result: currentResult } = evaluateFormula({\n        expressions,\n        macros: macrosWithCertainty(testValue),\n        rolls // don't need to pass a new one in because we mutate the old one\n      });\n      if (currentResult.every((value, index) => value === accum.slice(-1)[0].result[index])) {\n        return accum;\n      }\n      return [\n        ...accum.slice(0, -1),\n        {\n          ...accum.slice(-1)[0],\n          maxValue: testValue - 1,\n        },\n        {\n          minValue: testValue,\n          result: currentResult,\n          sideEffects,\n        }\n      ];\n    },\n    [\n      {\n        variable: uncertainValues[0],\n        minValue: 0,\n        result,\n        sideEffects: initialSideEffects,\n      }\n    ]\n  );\n\n/**\n * @typedef RolledFormula\n * @type {object}\n * @property {ResultEntry[]|ResultRange[]} result Either the results from evaluation OR an array\n *                                      of results at multiple input values for a given variable\n * @property {RollLog} rolls Log of all rolls made as part of the evaluation\n * @property {SideEffects} sideEffects Side effects applied from this roll\n * @property {MacroMap} macros Macros that were included in the initial expression\n * @property {MacroMap} allMacros All macros - expression, collection, and inline\n */\n\n/**\n * Validate, parse, and evaluate a formula, potentially pulling in collection data if needed\n * @function rollFormula\n * @param {string} formula\n * @param {object.<string,string>} collectionFormulasMap\n * @returns {RolledFormula}\n */\nexport const rollFormula = (formula, collectionFormulasMap) => {\n  const validity = validateFormula(formula);\n  if (validity.length > 0) {\n    return {\n      result: [`Invalid formula! Issues: ${validity.join(', ')}`],\n      rolls: [],\n    };\n  }\n  const tokens = tokenize(formula);\n\n  const { expressions, macros, unassignedVariables } = formulaParser.parseTokens(tokens);\n\n  const macrosFromCollection = unassignedVariables.length > 0\n    ? formulaParser.getMacrosFromCollection(collectionFormulasMap)\n    : {};\n\n  const { variables, usedMacros } = formulaParser.getUnassignedVariablesAndUsedMacros(\n    expressions, macros, macrosFromCollection\n  );\n\n  const noPromptVariables = variables.filter(variable =>\n    [...Object.values(usedMacros), ...expressions].some(clause => clause.some(\n        token => token === `^${variable}`\n    )));\n\n  // TODO: Determine newly required unassigned macros in the UI\n  //       Should only require calling getRollMetadata\n  const newMacros = variables\n    .filter(variable => !noPromptVariables.includes(variable))\n    .reduce((accum, variable) => {\n      const value = window.prompt(`Value of ${variable}`, '0');\n      return {\n        ...accum,\n        [variable]: [value],\n      };\n    }, {});\n  const allMacros = {\n    ...usedMacros,\n    ...newMacros,\n    ...noPromptVariables.map(variable => [variable, ['0']]).reduce(objectMakerReduceHelper, {})\n  };\n  const uncertainValues = Object.entries(allMacros)\n    .filter(([, tokens]) => tokens.length === 1 && tokens[0] === '?')\n    .map(([macroName]) => macroName);\n  if (uncertainValues.length > 1) {\n    throw new Error('Multiple uncertain values are not yet supported.');\n  }\n  if (uncertainValues.length === 0) {\n    const {result, rolls, sideEffects} = evaluateFormula({expressions, macros: allMacros});\n    return {result, rolls, sideEffects, allMacros, macros};\n  }\n  const macrosWithCertainty = value => ({\n    ...allMacros,\n    [uncertainValues[0]]: [`${value}`],\n  });\n  const { result, rolls, sideEffects: initialSideEffects } = evaluateFormula({ expressions, macros: macrosWithCertainty(0) });\n  const resultRange = buildResultRange({ expressions, macrosWithCertainty, result, rolls, uncertainValues, initialSideEffects });\n\n  return { result: resultRange, rolls, allMacros, macros };\n};\n\nexport default rollFormula;\n"],"file":"rollFormula.js"}