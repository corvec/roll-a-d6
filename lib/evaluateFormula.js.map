{"version":3,"sources":["evaluateFormula.mjs"],"names":["logEvaluate","log","args","console","evaluate","token","v1","v2","Math","floor","Error","rollAD","sides","evaluationMetadata","rollIsSaved","rollResult","rolls","rollIndex","parseInt","addRoll","getInitialRollIndex","map","side","reduce","objectMakerReduceHelper","length","random","hasOwnProperty","push","rollRoll","count","slice","indexOf","Array","keys","accum","isBoolean","includes","boolMap","true","false","toBoolean","isMacro","macros","getMacroName","target","getMacroIndex","match","isPlaceholder","isMacroInstance","test","macroName","isGlobalMacroInstance","getOrEvalMacroInstance","savedMacroValues","macroIndex","isArray","result","evaluateExpression","getExpansionOperatorData","expansionOperator","operator","initialValue","applyEvaluation","values","value","evaluateExpansionOperator","stack","tokenIndex","expression","repetitionCount","repeatedValue","expandedValues","newValue","join","_","evaluateOperator","evaluateValue","sideEffects","savedGlobalValues","storeCurrentValue","variableName","applySideEffect","val","evaluateConditional","ignoreToken","evaluateFormula","expressions","Object"],"mappings":"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","sourcesContent":["import {\n  getTargetCollection,\n  isConditional,\n  isExpansionOperator,\n  isOperator,\n  isRoll,\n  isSideEffectOperator,\n  isSideEffectVariable,\n  stripPrefix,\n  stripSuffix,\n  variableTargetsCollection,\n} from './formulaTokenizer';\nimport {objectMakerReduceHelper, peek} from './helpers';\n\n// TODO: [Tech Debt] Refactor this module to not mutate savedMacroValues or evaluationMetadata\n/* eslint fp/no-mutation: ['error', {\n     exceptions: [\n       {object: 'savedMacroValues'},\n       {object: 'evaluationMetadata', property: 'rollIndex'},\n       {object: 'evaluationMetadata', property: 'rolls'},\n       {object: 'evaluationMetadata', property: 'sideEffects'},\n     ]\n  }]\n*/\n\n// Toggle this on if you would like messages logged throughout evaluateFormula\nconst logEvaluate = false;\nconst log = (...args) => { if (logEvaluate) console.log(...args); };\n\n\n/**\n * @param {string} token Operator being applied\n * @param {string|number|boolean} v1 Top value on the stack\n * @param {string|number|boolean} v2 Second value on the stack\n * @returns {boolean|number|*}\n */\nconst evaluate = (token, v1, v2) => {\n  switch (token) {\n    case '+':\n      return v1 + v2;\n    case '-':\n      return v1 - v2;\n    case '*':\n      return v1 * v2;\n    case '/':\n      return Math.floor(v1 / v2);\n    case '>':\n      return v1 > v2;\n    case '<':\n      return v1 < v2;\n    case '>>':\n      return v1 > v2 ? v1 : v2;\n    case '<<':\n      return v1 < v2 ? v1 : v2;\n    case '>=':\n      return v1 >= v2;\n    case '<=':\n      return v1 <= v2;\n    case '<>':\n      return v1 !== v2;\n    case '==':\n      return v1 === v2;\n    case '||':\n      return v1 || v2;\n    case '&&':\n      return v1 && v2;\n    default:\n      throw new Error(`Unknown token: ${token}`);\n  }\n};\n\n\n/**\n * If `rolls` was provided (and thus, we have a `rollIndex`), then return the next roll.\n * Otherwise, generate the next roll and save it into rolls.\n * @param {number} sides\n * @param {EvaluationMetadata} evaluationMetadata\n * @returns {number}\n */\nconst rollAD = (sides, evaluationMetadata) => {\n  if (rollIsSaved(sides, evaluationMetadata)) {\n    const rollResult = evaluationMetadata.rolls[sides][evaluationMetadata.rollIndex[sides]];\n    evaluationMetadata.rollIndex[sides] += 1;\n    return parseInt(rollResult, 10);\n  } else {\n    return addRoll(sides, evaluationMetadata);\n  }\n};\n\n/**\n * @param {number[]} sides\n * @returns {object.<number, number>}\n */\nconst getInitialRollIndex = (sides) =>\n  sides.map(side => [side, 0]).reduce(objectMakerReduceHelper, {});\n\nconst rollIsSaved = (sides, evaluationMetadata) =>\n    typeof evaluationMetadata.rollIndex[sides] === 'number'\n    && evaluationMetadata.rollIndex[sides] < evaluationMetadata.rolls[sides].length;\n\nconst addRoll = (sides, evaluationMetadata) => {\n  const rollResult = Math.floor(sides * Math.random()) + 1;\n  if (!evaluationMetadata.rolls.hasOwnProperty(sides)) {\n    evaluationMetadata.rolls[sides] = [];\n  }\n  evaluationMetadata.rolls[sides].push(`${rollResult}(d${sides})`);\n  return rollResult;\n};\n\nconst rollRoll = (token, evaluationMetadata) => {\n  const count = parseInt(token.slice(0, token.indexOf('d')), 10) || 1;\n  const sides = parseInt(token.slice(1 + token.indexOf('d')), 10);\n  return [...Array(count).keys()].reduce((accum) => accum + rollAD(sides, evaluationMetadata), 0);\n};\n\nconst isBoolean = token => [true, false, 'true', 'false'].includes(token);\nconst boolMap = { true: true, false: false };\nconst toBoolean = token => boolMap.hasOwnProperty(token) ? boolMap[token] : token;\n\nconst isMacro = (token, macros) => macros.hasOwnProperty(stripPrefix(token));\n\n/**\n * @function\n * @example // returns 'atk@melee'\n * getMacroName('^atk@melee[0]')\n * @param {string} token\n * @returns {string}\n */\nconst getMacroName = token => {\n  const target = variableTargetsCollection(token) ? getTargetCollection(token) : null;\n  return `${stripPrefix(stripSuffix(token))}${target ? `@${target}` : ''}`;\n};\n/**\n * @function\n * @example // returns '1'\n * getMacroIndex('a[1]')\n * @param {string} token\n * @returns {string | *}\n */\nconst getMacroIndex = token => token.match(/[[{](\\d+)[}\\]]/)[1];\n\nconst isPlaceholder = token => token.match(/=>/);\n\n/**\n * (Local) Macro instances take the form of foo[1] and are not shared across multiple expressions\n *\n * @param {string} token\n * @param {object} macros\n * @returns {boolean}\n */\nconst isMacroInstance = (token, macros) => {\n  if (/[a-zA-Z]\\w*\\[\\d+]/.test(stripPrefix(token))) {\n    const macroName = getMacroName(token);\n    return macros.hasOwnProperty(macroName);\n  }\n  return false;\n};\n\n/**\n * Global Macro instances take the form of foo{1} and are shared across all expressions\n *\n * @param {string} token\n * @param {Array.<string>} macros\n * @returns {boolean}\n */\nconst isGlobalMacroInstance = (token, macros) => {\n  if (/[a-zA-Z]\\w*{\\d+}/.test(stripPrefix(token))) {\n    const macroName = getMacroName(token);\n    return macros.hasOwnProperty(macroName);\n  }\n  return false;\n};\n\nconst getOrEvalMacroInstance = (token, evaluationMetadata, savedMacroValues) => {\n  const macroName = getMacroName(token);\n  const macroIndex = parseInt(getMacroIndex(token), 10);\n\n  if (!Array.isArray(savedMacroValues[macroName])) {\n    savedMacroValues[macroName] = [];\n  }\n  if (savedMacroValues[macroName].hasOwnProperty(macroIndex)) {\n    return savedMacroValues[macroName][macroIndex];\n  }\n  const result = evaluateExpression(evaluationMetadata.macros[macroName], evaluationMetadata);\n  savedMacroValues[macroName][macroIndex] = result;\n  return result;\n};\n\nconst getExpansionOperatorData = expansionOperator => ({\n    '#+': {\n      operator: '+',\n      initialValue: 0,\n    },\n    '#*': {\n      operator: '*',\n      initialValue: 1,\n    },\n    '#&': {\n      operator: '&&',\n      initialValue: true\n    },\n    '#|': {\n      operator: '||',\n      initialValue: false,\n    },\n  }[expansionOperator]\n);\n\nconst applyEvaluation = (expansionOperator, values) => {\n  const { operator, initialValue } = getExpansionOperatorData(expansionOperator);\n  return values.reduce((accum, value) => evaluate(operator, accum, value), initialValue);\n};\n\nconst evaluateExpansionOperator = ({ stack, token, tokenIndex, expression, evaluationMetadata }) => {\n  if (stack.length < 2) {\n    throw new Error(`Expansion operator ${token} called with ${stack.length} operands (needs at least 2).`);\n  }\n  const repetitionCount = stack.slice(-2)[ 0 ];\n  if (repetitionCount <= 1) {\n    return [...stack.slice(0, -2), stack.slice(-1)[0]];\n  }\n  const repeatedValue = expression[ tokenIndex - 1 ];\n  if (isRoll(repeatedValue) || isMacro(repeatedValue, evaluationMetadata.macros)) {\n    const expandedValues = [\n      stack.slice(-1)[0],\n      ...([...Array(repetitionCount-1)].map(\n        () => (\n          isRoll(repeatedValue)\n            ? rollRoll(repeatedValue, evaluationMetadata)\n            : evaluateExpression(evaluationMetadata.macros[getMacroName(repeatedValue)], evaluationMetadata)\n        )\n      ))\n    ];\n    const newValue = applyEvaluation(token, expandedValues);\n    log(`complex expansion: ${stack.slice(-2).join(' ')} ${token} => ${newValue}`);\n    return [...stack.slice(0, -2), newValue];\n  } else {\n    const newValue = applyEvaluation(token, [...Array(repetitionCount)].map(_ => stack.slice(-1)[0]));\n    log(`simple expansion: ${stack.slice(-2).join(' ')} ${token} => ${newValue}`);\n    return [...stack.slice(0, -2), newValue];\n  }\n};\n\nconst evaluateOperator = ({ stack, token }) => {\n  if (stack.length < 2) {\n    throw new Error(`Operator ${token} called with ${stack.length} operands (needs at least 2).`);\n  } else {\n    const newValue = evaluate(token, ...stack.slice(-2));\n    log(`${stack.slice(-2).join(' ')} ${token} => ${newValue}`);\n    return [...stack.slice(0, -2), newValue];\n  }\n};\n\nconst evaluateValue = ({ stack, token, savedMacroValues, evaluationMetadata }) => {\n  const { macros } = evaluationMetadata;\n  const value = isRoll(token) ? rollRoll(token, evaluationMetadata)\n    : isMacro(token, macros)\n      ? evaluationMetadata.sideEffects.hasOwnProperty(getMacroName(token))\n        ? evaluationMetadata.sideEffects[getMacroName(token)]\n        : evaluateExpression(macros[getMacroName(token)], evaluationMetadata)\n    : isGlobalMacroInstance(token, macros) ? getOrEvalMacroInstance(token, evaluationMetadata, evaluationMetadata.savedGlobalValues)\n    : isMacroInstance(token, macros) ? getOrEvalMacroInstance(token, evaluationMetadata, savedMacroValues)\n    : isBoolean(token) ? toBoolean(token)\n    : parseInt(token, 10);\n  log(`${token} => ${value}`);\n  return [...stack, value];\n};\n\nconst storeCurrentValue = ({ variableName, evaluationMetadata }) => {\n  evaluationMetadata.sideEffects[variableName] =\n    isMacro(variableName, evaluationMetadata.macros)\n      ? evaluateExpression(evaluationMetadata.macros[variableName], evaluationMetadata)\n      : 0;\n};\n\nconst applySideEffect = ({ stack, token, evaluationMetadata, savedMacroValues }) => {\n  const variableName = getMacroName(stack[stack.length - 2]);\n  const val = peek(stack);\n  switch (token) {\n    case ':=':\n      evaluationMetadata.sideEffects[variableName] = val;\n      break;\n    case '+=':\n      if (!evaluationMetadata.sideEffects.hasOwnProperty(variableName)) {\n        storeCurrentValue({ variableName, evaluationMetadata, savedMacroValues });\n      }\n      evaluationMetadata.sideEffects[variableName] = evaluationMetadata.sideEffects[variableName] + val;\n      break;\n    case '-=':\n      if (!evaluationMetadata.sideEffects.hasOwnProperty(variableName)) {\n        storeCurrentValue({ variableName, evaluationMetadata, savedMacroValues });\n      }\n      evaluationMetadata.sideEffects[variableName] = evaluationMetadata.sideEffects[variableName] - val;\n      break;\n    default:\n      throw new Error(`applySideEffect - invalid token(${token}).`);\n  }\n  return stack.slice(0, -2);\n};\n\n// When we get a conditional placeholder (=>), check the top of the stack.\n// If it's truthy, then just keep the stack as is.\n// If it's falsy, then add => to the stack, which will clear anything added until we encounter ->\n// When we encounter a THEN (->), check the top of the stack.\n// If it's =>, clear => from the stack and continue.\n// Otherwise, add -> to the stack.\n// Finally, when we encounter ELSE (;), check the top of the stack.\n// If it's ->, clear it from the stack.\n// Otherwise, just return the stack.\nconst evaluateConditional = ({ stack, token, evaluationMetadata }) => {\n  switch (token) {\n    case '=>': // placeholder\n      if (peek(stack)) {\n        return stack;\n      } else {\n        return [...stack, token];\n      }\n    case '->':\n      if (peek(stack) === '=>') {\n        return stack.slice(0, -1);\n      } else {\n        return [...stack, token];\n      }\n    case ';':\n      if (peek(stack) === '->') {\n        return stack.slice(0, -1);\n      } else {\n        return stack;\n      }\n    default:\n      throw new Error('Invalid conditional setup');\n  }\n};\n\n// used to avoid traversing the falsy path with if-then conditionals\nconst ignoreToken = ({ stack }) => stack;\n\n/**\n * @param {RPNTokenList} expression\n * @param {EvaluationMetadata} evaluationMetadata\n * @returns {ResultEntry}\n */\nconst evaluateExpression = (expression, evaluationMetadata) => {\n  // Preserve the values of macros within a single expression\n  const savedMacroValues = {};\n  log(`evaluating ${expression && expression.join(' ')}`);\n  const result = expression.reduce((stack, token, tokenIndex) => {\n    if (isConditional(token)) {\n      return evaluateConditional({ stack, token, evaluationMetadata });\n    } else if (isConditional(peek(stack)) || token === '...') {\n      return ignoreToken({ stack });\n    } else if (isSideEffectVariable(token)) {\n      return [...stack, token];\n    } else if (isSideEffectOperator(token)) {\n      return applySideEffect({ stack, token, evaluationMetadata });\n    } else if (isExpansionOperator(token)) {\n      return evaluateExpansionOperator({ stack, token, tokenIndex, expression, evaluationMetadata });\n    } else if (isOperator(token)) {\n      return evaluateOperator({ stack, token });\n    } else {\n      return evaluateValue({ stack, token, evaluationMetadata, savedMacroValues });\n    }\n  }, []);\n  return result[result.length - 1];\n};\n\n/**\n * @typedef ResultEntry\n * @type {boolean|number|string}\n */\n\n/**\n * @typedef RollLog\n * @type {object.<number, string[]>}\n */\n\n/**\n * @typedef SideEffects\n * @type {object.<string, ResultEntry>}\n */\n\n/**\n * @typedef EvaluationMetadata\n * @type {object}\n * @property {Collection} macros    Available CollectionRolls that could be referenced\n * @property {RollLog} rolls    Map from number of sides to saved roll results\n *                              (e.g., {6: ['1(d6)','5(d6)']})\n * @property {object.<number, number>} rollIndex  Map from number of sides to roll index\n * @property {object.<string, ResultEntry[]>} savedGlobalValues  Saved results of macro instances\n * @property {SideEffects} sideEffects  Applied side effects this run\n */\n\n/**\n * @typedef EvaluationResult\n * @type {object}\n * @property {ResultEntry[]} result Result of each expression, in order\n * @property {RollLog} rolls Log of all rolls made as part of the evaluation\n * @property {SideEffects} sideEffects Changes to already calculated values, both internal to this\n *                                     evaluation and external\n */\n\n/**\n * Calculate the result of tokenized RPN expressions\n * @param {object} p\n * @param {Array<RPNTokenList>} p.expressions Expressions to evaluate\n * @param {MacroMap} p.macros Macros referenced by these expressions / by other macros\n * @param {object<number,string[]>} [p.rolls={}] Saved rolls (by number of sides), in case of reevaluation\n *\n * @returns {EvaluationResult}\n */\nconst evaluateFormula = ({ expressions, macros, rolls = {} }) => {\n  // @type EvaluationMetadata\n  const evaluationMetadata = {\n    macros,\n    rolls,\n    rollIndex: getInitialRollIndex(Object.keys(rolls).map(sides => parseInt(sides, 10))),\n    savedGlobalValues: {},\n    sideEffects: {},\n  };\n  const result = expressions.map(expression => evaluateExpression(\n    expression, evaluationMetadata,\n  ));\n  return { result, rolls: evaluationMetadata.rolls, sideEffects: evaluationMetadata.sideEffects };\n};\n\nexport default evaluateFormula;\n"],"file":"evaluateFormula.js"}