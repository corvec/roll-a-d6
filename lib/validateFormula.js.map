{"version":3,"sources":["validateFormula.mjs"],"names":["enableLogging","log","msg","console","validateParentheses","clause","Array","from","reduce","depth","currentChar","NaN","validateBrackets","brackets","match","every","bracket","test","validateAlternatingTokenType","tokens","accum","token","i","result","length","lastToken","validateClause","push","join","isValidToken","invalidTokens","filter","forEach","clauseHasMislocatedAssignmentOperator","some","validateFormula","formula","Error","clauses","split"],"mappings":"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","sourcesContent":["/*\n * Operations on this file are run on formulas prior to their conversion to RPN\n */\n\nimport tokenize, { isOperator, isValidToken, isValue, isVariable } from './formulaTokenizer';\n\nconst enableLogging = false;\nconst log = msg => { if (enableLogging) console.log(msg) };\n\n/**\n * Ensure parentheses are balanced\n * @function validateParentheses\n * @example\n * // returns false\n * validateParentheses('())(')\n * // return false\n * validateParentheses('(()')\n * // return true\n * validateParentheses('()')\n *\n * @param {string} clause\n * @returns {boolean} True if valid\n */\nexport const validateParentheses = clause =>\n  Array.from(clause).reduce((depth, currentChar) => {\n    switch (currentChar) {\n      case '(':\n        return depth + 1;\n      case ')':\n        if (depth <= 0) {\n          return NaN;\n        }\n        return depth - 1;\n      default:\n        return depth;\n    }\n  }, 0) === 0;\n\n/**\n * confirm that brackets are only used to contain numbers, e.g., [5]\n *\n * @param {string} clause\n * @returns {boolean} True if valid\n */\nconst validateBrackets = (clause) => {\n  const brackets = clause.match(/\\[[^[\\]]*]/g);\n  return brackets === null || brackets.every(bracket => /^\\[\\d+]$/.test(bracket));\n};\n\n/**\n * confirm that operators and values alternate\n * @function validateAlternatingTokenType\n * @param {string[]} tokens\n * @returns {boolean} True if valid\n */\nconst validateAlternatingTokenType = tokens => tokens.reduce(\n  (accum, token, i) => {\n    if (!accum) {\n      return false;\n    }\n    if (i === 0) {\n      const result = isValue(token) || token === '(';\n      if (!result) {\n        log(`clause did not start with ( or value, but with ${token}`)\n      }\n      return result;\n    }\n    if (i === tokens.length - 1 && (isOperator(token) || token === '(')) {\n      log(`last token in the clause was ${token}`);\n      return false;\n    }\n    const lastToken = tokens[i-1];\n    if (token === '=') {\n      const result = (i === 1 && isVariable(lastToken));\n      if (!result) {\n        log('= was not the second token or did not follow a variable name');\n      }\n      return result;\n    }\n    if (isOperator(lastToken) || lastToken === '(' || lastToken === '=') {\n      const result = isValue(token) || token === '(';\n      if (!result) {\n        log(`An operator, =, or ( was followed by ${token}`);\n      }\n      return result;\n    }\n    if (isValue(lastToken) || lastToken === ')') {\n      const result = isOperator(token) || token === ')';\n      if (!result) {\n        log(`A value or ) was followed by ${token}`);\n      }\n      return result;\n    }\n    return false;\n  },\n    true\n);\n\n/**\n * Confirm that the clause matches the appropriate format and that the other validators pass\n * @function validateClause\n * @param {string} clause\n * @param {number|string} i clause descriptor\n * @returns {string[]} Empty if valid. Array of found issues.\n */\nexport const validateClause = (clause, i) => {\n  const result = [];\n\n  // TODO: source valid strings from formulaTokenizer.js or some other shared place instead\n  if (clause.length === 0 || !clause.match(/^([\\^$]?\\w(@\\w+)?|[#+\\-*/<>=:;()[\\]{}|&?.])+$/)) {\n    log(`${clause} did not match validation regex`);\n    result.push(`Invalid characters in clause ${i}`);\n  }\n  if (!validateBrackets(clause)) {\n    log(`${clause} did not have valid brackets`);\n    result.push(`Invalid brackets in clause ${i}`);\n  }\n  if (!validateParentheses(clause)) {\n    log(`${clause} did not have valid parentheses`);\n    result.push(`Invalid parentheses in clause ${i}`);\n  }\n  const tokens = tokenize(clause);\n  if (tokens == null || tokens.length === 0 || tokens.join('') !== clause) {\n    log(`${clause} could not be tokenized`);\n    result.push(`Clause ${i} could not be tokenized`);\n    return result;\n  }\n  if (!tokens.every(isValidToken)) {\n    log(`${clause} had one or more invalid tokens`);\n    const invalidTokens = tokens.filter(token => !isValidToken(token));\n    result.push(`Clause ${i} had invalid tokens: ${invalidTokens.join(', ')}`);\n\n    if (enableLogging) {\n      invalidTokens.forEach(\n        token => console.log(`Invalid token: ${token}`)\n      );\n    }\n    return result;\n  }\n  if (!validateAlternatingTokenType(tokens)) {\n    log(`${clause} did not have proper token order`);\n    result.push(`${clause} had improper token order`);\n  }\n  return result;\n};\n\n/**\n * Ensure that assignment only happens at the beginning of a clause\n * @function clauseHasMislocatedAssignmentOperator\n * @param {string[]} clause List of tokens\n * @returns {boolean} True if valid\n */\nexport const clauseHasMislocatedAssignmentOperator = clause => clause.some(\n    (token, i) => token === '='\n        && (clause.length < 3\n            || i !== 1\n            || !clause[0].match(/^[A-Za-z]\\w*(@[A-Za-z]\\w+)?$/))\n);\n\n/**\n * Perform validation for the entire formula (an unconverted string) one clause at a time\n * @function validateFormula\n * @param {string} formula\n * @returns {string[]} Empty if valid. Array of issues found.\n */\nexport const validateFormula = (formula) => {\n  if (typeof formula !== \"string\") {\n      throw new Error('validateFormula() called with an invalid formula (i.e., of a non-string type)')\n  }\n  const clauses = formula.split(',');\n  const result = clauses.reduce(\n    (accum, clause, i) => [\n      ...accum,\n      ...validateClause(clause, i + 1),\n    ],\n    []\n  );\n  if (!enableLogging) {\n    return result;\n  }\n  if (!result) {\n    clauses.filter(clause => !validateClause(clause))\n      .forEach(clause => log(`invalid clause: ${clause}`));\n  }\n  return result;\n};\n\n\nexport default validateFormula;\n"],"file":"validateFormula.js"}