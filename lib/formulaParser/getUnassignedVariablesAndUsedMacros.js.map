{"version":3,"sources":["getUnassignedVariablesAndUsedMacros.mjs"],"names":["getNewVariablesReduceHelper","variables","accum","expressions","Set","filter","token","map","stripPrefix","variable","hasOwnProperty","stripSuffix","getUnassignedVariablesAndUsedMacrosHelper","usedMacros","unusedMacros","rpn","Object","values","reduce","length","newUsedMacros","helpers","formula","keys","newUnusedMacros","entries","key","objectMakerReduceHelper","getUnassignedVariablesAndUsedMacros","macros","macrosFromCollection","macroName"],"mappings":";;;;;;;AAAA;;AACA;;AAEA;;;;;;;AAOA,MAAMA,2BAA2B,GAAG,CAACC,SAAS,GAAG,EAAb,KAClC,CAACC,KAAD,EAAQC,WAAR,KAAwB,CAAC,GAAG,IAAIC,GAAJ,CAAQ,CAClC,GAAGF,KAD+B,EAElC,GAAGC,WAAW,CAACE,MAAZ,CAAmBC,KAAK,IAAI,kCAAWA,KAAX,CAA5B,EACAC,GADA,CACIC,6BADJ,EAEAH,MAFA,CAEOI,QAAQ,IAAI,CAACR,SAAS,CAACS,cAAV,CAAyBD,QAAzB,CAFpB,CAF+B,EAKlC,GAAGN,WAAW,CAACE,MAAZ,CAAmBC,KAAK,IAAI,0CAAmBA,KAAnB,CAA5B,EACAC,GADA,CACIC,6BADJ,EAEAD,GAFA,CAEII,6BAFJ,EAGAN,MAHA,CAGOI,QAAQ,IAAI,CAACR,SAAS,CAACS,cAAV,CAAyBD,QAAzB,CAHpB,CAL+B,CAAR,CAAJ,CAD1B;;AAaA,MAAMG,yCAAyC,GAAG,CAACT,WAAD,EAAcU,UAAd,EAA0BC,YAA1B,KAA2C;AAC3F,QAAMC,GAAG,GAAG,CAAC,GAAGZ,WAAJ,EAAiB,GAAGa,MAAM,CAACC,MAAP,CAAcJ,UAAd,CAApB,CAAZ;AACA,QAAMZ,SAAS,GAAGc,GAAG,CAACG,MAAJ,CAAWlB,2BAA2B,CAACa,UAAD,CAAtC,EAAoD,EAApD,CAAlB;;AACA,MAAIZ,SAAS,CAACkB,MAAV,KAAqB,CAAzB,EAA4B;AAC1B,WAAO;AAAElB,MAAAA,SAAF;AAAaY,MAAAA;AAAb,KAAP;AACD;;AACD,QAAMO,aAAa,GAAGnB,SAAS,CAACiB,MAAV,CACpB,CAAChB,KAAD,EAAQO,QAAR,KACEK,YAAY,CAACJ,cAAb,CAA4BD,QAA5B,IACI,EACA,GAAGK,YAAY,CAACL,QAAD,CAAZ,CAAuBY,OAD1B;AAEA,OAAGnB,KAFH;AAGA,KAACO,QAAD,GAAYK,YAAY,CAACL,QAAD,CAAZ,CAAuBa;AAHnC,GADJ,GAMIpB,KARc,EAUlBW,UAVkB,CAAtB;;AAWA,MAAIG,MAAM,CAACO,IAAP,CAAYH,aAAZ,EAA2BD,MAA3B,KAAsCH,MAAM,CAACO,IAAP,CAAYV,UAAZ,EAAwBM,MAAlE,EAA0E;AACxE,WAAO;AAAElB,MAAAA,SAAF;AAAaY,MAAAA;AAAb,KAAP;AACD;;AACD,QAAMW,eAAe,GAAGR,MAAM,CAACS,OAAP,CAAeX,YAAf,EACrBT,MADqB,CACd,CAAC,CAACqB,GAAD,CAAD,KAAW,CAACN,aAAa,CAACV,cAAd,CAA6BgB,GAA7B,CADE,EAErBR,MAFqB,CAEdS,gCAFc,EAEW,EAFX,CAAxB;AAIA,SAAOf,yCAAyC,CAACT,WAAD,EAAciB,aAAd,EAA6BI,eAA7B,CAAhD;AACD,CAzBD;AA2BA;;;;;;;AAOA;;;;;;;;;;;AASA,MAAMI,mCAAmC,GAAG,CAACzB,WAAD,EAAc0B,MAAd,EAAsBC,oBAAoB,GAAG,EAA7C,KAAoD;AAC9F,QAAMhB,YAAY,GAAG,EACnB,GAAGgB,oBADgB;AAEnB,OAAGd,MAAM,CAACS,OAAP,CAAeI,MAAf,EAAuBtB,GAAvB,CACD,CAAC,CAACwB,SAAD,EAAYT,OAAZ,CAAD,KAA0B,CAACS,SAAD,EAAY;AAAET,MAAAA,OAAF;AAAWD,MAAAA,OAAO,EAAE;AAApB,KAAZ,CADzB,EAEAH,MAFA,CAEOS,gCAFP,EAEgC,EAFhC;AAFgB,GAArB;AAMA,SAAOf,yCAAyC,CAACT,WAAD,EAAc,EAAd,EAAkBW,YAAlB,CAAhD;AACD,CARD;;eAUec,mC","sourcesContent":["import { isVariable, isVariableInstance, stripPrefix, stripSuffix } from '../formulaTokenizer';\nimport { objectMakerReduceHelper } from '../helpers';\n\n/**\n * Returns a reducer helper that will, given a list of already known variables, return a list of\n * any variables not already listed.\n *\n * @param {object<string, string>} variables The variables that are already known\n * @returns {function(string[], RPNTokenList): string[]}\n */\nconst getNewVariablesReduceHelper = (variables = {}) =>\n  (accum, expressions) => [...new Set([\n    ...accum,\n    ...expressions.filter(token => isVariable(token))\n      .map(stripPrefix)\n      .filter(variable => !variables.hasOwnProperty(variable)),\n    ...expressions.filter(token => isVariableInstance(token))\n      .map(stripPrefix)\n      .map(stripSuffix)\n      .filter(variable => !variables.hasOwnProperty(variable)),\n  ])];\n\n\nconst getUnassignedVariablesAndUsedMacrosHelper = (expressions, usedMacros, unusedMacros) => {\n  const rpn = [...expressions, ...Object.values(usedMacros)];\n  const variables = rpn.reduce(getNewVariablesReduceHelper(usedMacros), []);\n  if (variables.length === 0) {\n    return { variables, usedMacros };\n  }\n  const newUsedMacros = variables.reduce(\n    (accum, variable) => (\n      unusedMacros.hasOwnProperty(variable)\n        ? {\n          ...unusedMacros[variable].helpers,\n          ...accum,\n          [variable]: unusedMacros[variable].formula,\n        }\n        : accum\n    )\n    , usedMacros);\n  if (Object.keys(newUsedMacros).length === Object.keys(usedMacros).length) {\n    return { variables, usedMacros };\n  }\n  const newUnusedMacros = Object.entries(unusedMacros)\n    .filter(([key]) => !newUsedMacros.hasOwnProperty(key))\n    .reduce(objectMakerReduceHelper, {});\n\n  return getUnassignedVariablesAndUsedMacrosHelper(expressions, newUsedMacros, newUnusedMacros);\n};\n\n/**\n * @typedef UnassignedVariablesAndUsedMacros\n * @type {object}\n * @property {string[]} variables - The unassigned variables\n * @property {MacroMap} usedMacros - Macros that have been referenced and that thus need to be pulled in\n */\n\n/**\n * Given one or more expressions, determine which macros are needed, and pull in only those.\n *\n * @param {RPNTokenList[]} expressions - The expressions that are being evaluated.\n * @param {MacroMap} macros - Macros internal to the expression\n * @param {Collection} [macrosFromCollection={}]\n *\n * @returns {UnassignedVariablesAndUsedMacros}\n */\nconst getUnassignedVariablesAndUsedMacros = (expressions, macros, macrosFromCollection = {}) => {\n  const unusedMacros = {\n    ...macrosFromCollection,\n    ...Object.entries(macros).map(\n      ([macroName, formula]) => [macroName, { formula, helpers: {} }])\n      .reduce(objectMakerReduceHelper, {}),\n  };\n  return getUnassignedVariablesAndUsedMacrosHelper(expressions, {}, unusedMacros);\n};\n\nexport default getUnassignedVariablesAndUsedMacros;\n"],"file":"getUnassignedVariablesAndUsedMacros.js"}