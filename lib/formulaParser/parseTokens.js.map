{"version":3,"sources":["parseTokens.mjs"],"names":["parseAssignments","clauses","reduce","accum","clause","index","length","assignments","strippedClauses","slice","parseTokens","tokens","some","clauseHasMislocatedAssignmentOperator","offendingClauses","filter","Error","map","c","join","rpn","clauseTokens","macros","Object","entries","assignment","expressions","_","values","includes","unassignedVariables","variables","noPromptVariables","variable","token"],"mappings":";;;;;;;AAAA;;AACA;;AACA;;AACA;;;;AAEA;;;;;;;AAOA;;;;;;;;;AASA,MAAMA,gBAAgB,GAAGC,OAAO,IAAIA,OAAO,CAACC,MAAR,CAAe,CAACC,KAAD,EAAQC,MAAR,EAAgBC,KAAhB,KAA0B;AAC3E,MAAID,MAAM,CAACE,MAAP,IAAiB,CAAjB,IAAsBF,MAAM,CAAC,CAAD,CAAN,KAAc,GAAxC,EAA6C;AAC3C,WAAO;AACLG,MAAAA,WAAW,EAAE,EACX,GAAGJ,KAAK,CAACI,WADE;AAEX,SAACH,MAAM,CAAC,CAAD,CAAP,GAAaC;AAFF,OADR;AAKLG,MAAAA,eAAe,EAAE,CAAC,GAAGL,KAAK,CAACK,eAAV,EAA2BJ,MAAM,CAACK,KAAP,CAAa,CAAb,CAA3B;AALZ,KAAP;AAOD,GARD,MAQO;AACL,WAAO,EACL,GAAGN,KADE;AAELK,MAAAA,eAAe,EAAE,CAAC,GAAGL,KAAK,CAACK,eAAV,EAA2BJ,MAA3B;AAFZ,KAAP;AAID;AACF,CAfmC,EAejC;AAAEG,EAAAA,WAAW,EAAE,EAAf;AAAmBC,EAAAA,eAAe,EAAE;AAApC,CAfiC,CAApC;AAkBA;;;;;;;;;AASA;;;;;;;;;;AAQA,MAAME,WAAW,GAAIC,MAAD,IAAY;AAC9B,QAAMV,OAAO,GAAG,sCAAeU,MAAf,CAAhB;;AACA,MAAIV,OAAO,CAACW,IAAR,CAAaC,sDAAb,CAAJ,EAAyD;AACvD,UAAMC,gBAAgB,GAAGb,OAAO,CAACc,MAAR,CAAeF,sDAAf,CAAzB;AACA,UAAM,IAAIG,KAAJ,CAAW,mEACfF,gBAAgB,CAACG,GAAjB,CAAqBC,CAAC,IAAIA,CAAC,CAACC,IAAF,CAAO,GAAP,CAA1B,EAAuCA,IAAvC,CAA4C,GAA5C,CACD,EAFK,CAAN;AAGD;;AACD,QAAM;AAAEZ,IAAAA,WAAF;AAAeC,IAAAA;AAAf,MAAmCR,gBAAgB,CAACC,OAAD,CAAzD;AAEA,QAAMmB,GAAG,GAAGZ,eAAe,CAACS,GAAhB,CAAoBI,YAAY,IAAI,2BAAaA,YAAb,CAApC,CAAZ;AACA,QAAMC,MAAM,GAAGC,MAAM,CAACC,OAAP,CAAejB,WAAf,EAA4BL,MAA5B,CACb,CAACC,KAAD,EAAQ,CAACsB,UAAD,EAAapB,KAAb,CAAR,MAAiC,EAC/B,GAAGF,KAD4B;AAE/B,KAACsB,UAAD,GAAcL,GAAG,CAACf,KAAD;AAFc,GAAjC,CADa,EAIT,EAJS,CAAf;AAKA,QAAMqB,WAAW,GAAGN,GAAG,CAACL,MAAJ,CAAW,CAACY,CAAD,EAAItB,KAAJ,KAAc,CAACkB,MAAM,CAACK,MAAP,CAAcrB,WAAd,EAA2BsB,QAA3B,CAAoCxB,KAApC,CAA1B,CAApB;AACA,QAAMyB,mBAAmB,GAAG,kDAAoCJ,WAApC,EAAiDJ,MAAjD,EAAyDS,SAArF;AACA,QAAMC,iBAAiB,GAAGF,mBAAmB,CAACf,MAApB,CACxBkB,QAAQ,IAAIb,GAAG,CAACR,IAAJ,CAASR,MAAM,IAAIA,MAAM,CAACQ,IAAP,CAC7BsB,KAAK,IAAIA,KAAK,KAAM,IAAGD,QAAS,EADH,CAAnB,CADY,CAA1B;AAIA,SAAO;AAAEP,IAAAA,WAAF;AAAeJ,IAAAA,MAAf;AAAuBQ,IAAAA,mBAAvB;AAA4CE,IAAAA;AAA5C,GAAP;AACD,CAvBD;;eAyBetB,W","sourcesContent":["import { clauseHasMislocatedAssignmentOperator } from '../validateFormula';\nimport convertToRPN from '../rpnConverter';\nimport { splitTokenList } from '../formulaTokenizer';\nimport getUnassignedVariablesAndUsedMacros from './getUnassignedVariablesAndUsedMacros';\n\n/**\n * @typedef ParsedAssignments\n * @type {object}\n * @property {object.<string, number>} assignments - references to the clauses by index\n * @property {string[][]} strippedClauses - clauses without the assignments\n */\n\n/**\n * Get the assignments from a set of tokenized, but not RPNed, clauses.\n * In the response, the assignments will reference the clauses by index.\n * @function parseAssignments\n *\n * @param {string[][]} clauses\n *\n * @returns {ParsedAssignments}\n */\nconst parseAssignments = clauses => clauses.reduce((accum, clause, index) => {\n  if (clause.length >= 3 && clause[1] === '=') {\n    return {\n      assignments: {\n        ...accum.assignments,\n        [clause[0]]: index,\n      },\n      strippedClauses: [...accum.strippedClauses, clause.slice(2)],\n    };\n  } else {\n    return {\n      ...accum,\n      strippedClauses: [...accum.strippedClauses, clause],\n    };\n  }\n}, { assignments: {}, strippedClauses: [] });\n\n\n/**\n * @typedef ParsedTokenList\n * @type {object}\n * @property {RPNTokenList[]} expressions - Top level expressions\n * @property {MacroMap} macros - Internal macros\n * @property {string[]} unassignedVariables - Variables that are referenced but not assigned\n * @property {string[]} noPromptVariables - Unassigned variables that should not be prompted for\n */\n\n/**\n * Parse tokens in preparation for evaluation or analysis\n * @function parseTokens\n *\n * @param {string[]} tokens Token list in infix notation\n *\n * @returns {ParsedTokenList}\n */\nconst parseTokens = (tokens) => {\n  const clauses = splitTokenList(tokens);\n  if (clauses.some(clauseHasMislocatedAssignmentOperator)) {\n    const offendingClauses = clauses.filter(clauseHasMislocatedAssignmentOperator)\n    throw new Error(`Assignment is only supported at the very beginning of a clause: ${\n      offendingClauses.map(c => c.join(' ')).join(',')\n    }`);\n  }\n  const { assignments, strippedClauses } = parseAssignments(clauses);\n\n  const rpn = strippedClauses.map(clauseTokens => convertToRPN(clauseTokens));\n  const macros = Object.entries(assignments).reduce(\n    (accum, [assignment, index]) => ({\n      ...accum,\n      [assignment]: rpn[index],\n    }), {});\n  const expressions = rpn.filter((_, index) => !Object.values(assignments).includes(index));\n  const unassignedVariables = getUnassignedVariablesAndUsedMacros(expressions, macros).variables;\n  const noPromptVariables = unassignedVariables.filter(\n    variable => rpn.some(clause => clause.some(\n      token => token === `^${variable}`\n    )));\n  return { expressions, macros, unassignedVariables, noPromptVariables };\n};\n\nexport default parseTokens;\n"],"file":"parseTokens.js"}