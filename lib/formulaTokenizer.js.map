{"version":3,"sources":["formulaTokenizer.mjs"],"names":["conditionals","logicals","comparators","arithmetic","expansion","sideEffects","operatorOrder","isConditional","token","includes","isOperator","isExpansionOperator","isSideEffectOperator","isVariable","test","isVariableInstance","isSideEffectVariable","isNumber","isNaN","parseInt","isRoll","isGrouping","isValue","isValidToken","targetCollectionRegex","variableTargetsCollection","getTargetCollection","match","slice","stripPrefix","variable","replace","stripSuffix","variableInstance","splitTokenList","tokens","reduce","accum","length","tokenRegex","tokenize","formula"],"mappings":"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","sourcesContent":["export const conditionals = ['->', ';', '=>'];\nexport const logicals = ['&&', '||'];\nexport const comparators = ['>', '<', '<=', '>=', '==', '<>', '>>', '<<'];\nexport const arithmetic = ['+', '-', '*', '/'];\nexport const expansion = ['#+', '#*', '#|', '#&'];\nexport const sideEffects = [':=','+=','-=', '...'];\n\n/**\n * Used for order of operations when converting to RPN. Earlier groups have a higher precedence than later groups.\n * @example // 5+(6*7)\n * 5+6*7\n * @example // (5+6)>(7*8)\n * 5+6>7*8\n * @example // (5>6)|(7<8)\n * 5>6|7<8\n * @example // ((10+1d4)>>1d20)#+(6+1d6)\n * 10+1d4>>1d20#+6+1d6\n * @example // (((10+1d4)>>1d20)#+(6+1d6)<20)->1d8;0\n * 10+1d4>>1d20#+6+1d6->1d8;0\n *\n * @type {string[][]}\n */\nexport const operatorOrder = [\n  ['(', ')'], conditionals, expansion, logicals, comparators, ['+', '-'], ['*', '/'], sideEffects\n];\n\n/**\n * @function\n * @param {string} token\n * @return {boolean}\n */\nexport const isConditional = token => conditionals.includes(token);\n/**\n * @function\n * @param {string} token\n * @return {boolean}\n */\nexport const isOperator = token => [...arithmetic, ...comparators, ...logicals, ...expansion, ...conditionals, ...sideEffects].includes(token);\n/**\n * @function\n * @param {string} token\n * @return {boolean}\n */\nexport const isExpansionOperator = token => expansion.includes(token);\n/**\n * @function\n * @param {string} token\n * @return {boolean}\n */\nexport const isSideEffectOperator = token => sideEffects.includes(token);\n\n/**\n * @function\n * @param {string} token\n * @return {boolean}\n */\nexport const isVariable = token => (/^[\\^$]?[a-zA-Z]\\w*(@[A-Za-z]\\w*)?$/.test(token));\n/**\n * @function\n * @param {string} token\n * @return {boolean}\n */\nexport const isVariableInstance = token => (/^[a-zA-Z]\\w*(\\[\\d+]|{\\d+})(@[A-Za-z]\\w*)?$/.test(token));\n/**\n * @function\n * @param {string} token\n * @return {boolean}\n */\nexport const isSideEffectVariable = token => (/^\\$[a-zA-Z]\\w*(@[A-Za-z]\\w*)?$/.test(token));\n\n/**\n * @function\n * @param {string} token\n * @return {boolean}\n */\nexport const isNumber = token => !isNaN(token) && ['string','number'].includes(typeof token)\n  && !isNaN(parseInt(token, 10));\n\n/**\n * Is the token a roll (e.g., '3d6')?\n * @function isRoll\n * @param {string} token\n * @returns {boolean}\n */\nexport const isRoll = token => /\\d+d\\d+/.test(token);\n/**\n * Is the token a grouping operator (either '(' or ')')?\n * @function isGrouping\n * @param {string} token\n * @returns {boolean}\n */\nexport const isGrouping = token => ['(', ')'].includes(token);\n\n/**\n * Is the token a dice roll (e.g., '3d6')?\n * @function isValue\n * @param {string} token\n * @returns {boolean}\n */\nexport const isValue = token => isVariable(token) || isVariableInstance(token) || isRoll(token) || isNumber(token) || token === '?';\n\n/**\n * Is the token valid?\n * @function isValidToken\n * @param {string} token\n * @returns {boolean}\n */\nexport const isValidToken = token => isOperator(token) || isValue(token) || isGrouping(token) || ['=', '?'].includes(token);\n\n\nconst targetCollectionRegex = /@[A-Za-z]\\w+$/;\n/**\n * Is this token a variable with a target collection (e.g., 'ac@Defender', which targets 'Defender')\n * @function variableTargetsCollection\n * @param {string} token\n * @returns {boolean}\n */\nexport const variableTargetsCollection = token => (targetCollectionRegex.test(token));\n/**\n * Get the name of the targeted collection\n * @function getTargetCollection\n * @example // returns 'Defender'\n * getTargetCollection('ac@Defender')\n * @param {string} token\n * @returns {string?}\n */\nexport const getTargetCollection = token => {\n  const match = token.match(targetCollectionRegex);\n  return match && match[0].slice(1);\n};\n\n\n/**\n * Strip ^ and $ prefixes off of a token that is a variable name\n * @function stripPrefix\n * @example // returns 'ac'\n * stripPrefix('^ac')\n * @param {string} variable\n * @returns {string}\n */\nexport const stripPrefix = variable => variable.replace(/^[\\^$]+/, '');\n/**\n * Strip target and instance suffixes off of a token that is a variable instance\n * @function stripSuffix\n * @example // returns 'atk'\n * stripPrefix('atk[1]')\n * @param {string} variableInstance\n * @returns {string}\n */\nexport const stripSuffix = variableInstance => variableInstance\n  .replace(/@[A-Z]\\w*$/, '')\n  .replace(/(\\[.*]|{.*})$/, '');\n\n/**\n * Split a tokenized list into multiple tokenized lists based on the comma token\n * @function splitTokenList\n * @example // returns [['a'],['c']]\n * splitTokenList(['a', ',', 'c'])\n *\n * @param {string[]} tokens\n * @returns {string[][]}\n */\nexport const splitTokenList = tokens => tokens.reduce((accum, token) => {\n  if (token === ',') {\n    return [...accum, []];\n  } else {\n    return [\n      ...accum.slice(0, -1),\n      [\n        ...accum[accum.length - 1],\n        token,\n      ],\n    ];\n  }\n}, [[]]);\n\n/**\n * Every token MUST match this Regex.\n * @private\n * @type {RegExp}\n */\nconst tokenRegex = /([\\^$]?[A-Za-z]\\w*(\\[\\d+]|{\\d+})?(@[A-Za-z]\\w*)?|\\w+\\b|[()]|[:+\\-]=|\\.\\.\\.|->|#[+*&|]|[+*/,;]|[<>=]{1,2}|[|]{2}|&&|\\B-\\d+|-|\\?)/g;\n\n/**\n * Convert a formula from a string into an array of tokens\n * Each token should represent either a value or an operator.\n * @function tokenize\n * @example // returns ['1d20', '+', '5']\n * tokenize('1d20+5')\n *\n * @param {string} formula\n * @returns {string[]} Array of tokens\n */\nexport const tokenize = formula => formula.match(tokenRegex);\n\nexport default tokenize;\n"],"file":"formulaTokenizer.js"}